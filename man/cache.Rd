% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cache.R
\docType{methods}
\name{Cache}
\alias{Cache}
\alias{Cache,ANY-method}
\title{Cache method that accommodates environments, S4 methods, Rasters}
\usage{
Cache(FUN, ..., notOlderThan = NULL, objects = NULL, outputObjects = NULL,
  algo = "xxhash64", cacheRepo = NULL, compareRasterFileLength = 1e+06,
  userTags = c(), digestPathContent = FALSE, debugCache = FALSE)

\S4method{Cache}{ANY}(FUN, ..., notOlderThan = NULL, objects = NULL,
  outputObjects = NULL, algo = "xxhash64", cacheRepo = NULL,
  compareRasterFileLength = 1e+06, userTags = c(),
  digestPathContent = FALSE, debugCache = FALSE)
}
\arguments{
\item{FUN}{A function to be called.}

\item{...}{Arguments of \code{FUN} function .}

\item{notOlderThan}{load an artifact from the database only if it was created after notOlderThan.}

\item{objects}{Character vector of objects to be digested. This is only applicable
if there is a list, environment or simList with named objects
within it. Only this/these objects will be considered for caching,
i.e., only use a subset of
the list, environment or simList objects.}

\item{outputObjects}{Optional character vector indicating which objects to
return. This is only relevant for \code{simList} objects}

\item{algo}{The algorithms to be used; currently available choices are
    \code{md5}, which is also the default, \code{sha1}, \code{crc32},
    \code{sha256}, \code{sha512}, \code{xxhash32}, \code{xxhash64} and
    \code{murmur32}.}

\item{cacheRepo}{A repository used for storing cached objects.
This is optional if \code{Cache} is used inside a SpaDES module.}

\item{compareRasterFileLength}{Numeric. Optional. When there are Rasters, that
have file-backed storage, this is passed to the length arg in \code{digest}
when determining if the Raster file is already in the database.
Note: uses \code{\link[digest]{digest}} for file-backed Raster.
Default 1e6. Passed to \code{prepareFileBackedRaster}.}

\item{userTags}{A character vector with Tags. These Tags will be added to the repository along with the artifact.}

\item{digestPathContent}{Logical. Should arguments that are of class "Path"
(see examples below) have their name digested
(FALSE, the default), or their
file contents (TRUE)}

\item{debugCache}{Logical. If \code{TRUE}, then the returned object from the Cache
function will have two attributes, "debugCache1" and "debugCache2" which
are the entire list(...) and that same object, but
after all "robustDigest" calls, at the moment that it is digested using
\code{fastdigest}, respectively. This \code{attr(mySimOut, "debugCache2")} can
then be compared to
a subsequent call and individual items within the object
\code{attr(mySimOut, "debugCache1")} can be compared.}
}
\value{
As with \code{\link[archivist]{cache}}, the return is either the return
value of the function call or the cached version (i.e., the result from a previous
call to this same cached function with identical arguments).

If \code{Cache} is called within a SpaDES module, then the cached entry will automatically
get 3 extra \code{userTags}: eventTime, eventType, and moduleName. These can then be used in
\code{clearCache} to selectively remove cached objects by eventTime, eventType or moduleName.

\code{Cache} will add a tag to the artifact in the database
called \code{accessed} which will assign the time that it was
accessed, either read or write. That way, artifacts can be shown (\code{showCache})
or removed \code{clearCache} selectively based on their accessed
 dates, rather than only by their
creation dates. See example in \code{\link{clearCache}}.
}
\description{
This function takes elements from \code{\link[archivist]{cache}}, with
four very critical modifications:
1) the \code{archivist} package detects different environments as different;
2) it also does not detect S4 methods correctly due to method inheritance;
3) it does not detect objects that have file-base storage of information
(specifically \code{\link[raster]{RasterLayer-class}} objects).
4) the default hashing method is relatively slow
This version of the \code{Cache} function accommodates those four special,
though quite common, cases by:
1) converting any environments into list equivalents;
2) identifying the dispatched S4 method (including those made through
inheritance) before \code{\link[fastdigest]{fastdigest}} is called so the correct
method is being cached;
and 3) by running \code{\link[digest]{digest}} on the linked file. Currently,
only file-backed \code{Raster*} objects are digested (e.g., not \code{ff} objects,
or any other R object where the data is in a file, rather than RAM object).
4) We use \code{\link[fastdigest]{fastdigest}} internally when the object is
in RAM (i.e., not for file-backed objects0) which appears to be up to
10x faster than \code{\link[digest]{digest}}.
}
\details{
\code{Cache} (uppercase C) is used here so that it is not confused with and does
not mask the \code{archivist::cache} function.
}
\note{
As indicated above, several objects require pre-treatment before
caching will work as expected. The function \code{robustDigest} accommodates this.
It is an S4 generic, meaning that developers can produce their own methods for
different classes of objects. Currently, there are methods for several types
of classes. See \code{\link{robustDigest}} .

See \code{\link{robustDigest}} for other specifics for other classes.

In general, it is expected that caching will only be used when stochasticity
is not relevant, or if a user has achieved sufficient stochasticity (e.g., via
sufficient number of calls to \code{experiment}) such that no new explorations
of stochastic outcomes are required. It will also be very useful in a
reproducible work flow

If a function has a path argument, there is some ambiguity about what should be
done. Possiblities: digest the string as is (this will be very system specific,
meaning a Cache will not work if copied between systems or directories), digest
the basename(path), or digest the contents of the file. If paths are passed in as
is (i.e,. character string), the result will not be entirely predictable. Instead,
one should use the wrapper function asPath(path), and one should decide whether
one wants to digest the content of the file (\code{digestPathContent = TRUE})
or just the filename (\code{(digestPathContent = FALSE)}). See example.
}
\examples{
\dontrun{

library(raster)
tmpdir <- tempdir()
ras <- raster(extent(0,100,0,100), res = 1,
              vals = sample(1:5, replace=TRUE, size = 1e4),
              crs = "+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +ellps=WGS84")

# A slow operation, like GIS operation
notCached <- projectRaster(ras, crs=crs(ras), res = 5, cacheRepo=tmpdir) #
cached <- Cache(projectRaster, ras, crs=crs(ras), res = 5, cacheRepo=tmpdir) #
# 2nd time is much faster
reRun <- Cache(projectRaster, ras, crs=crs(ras), res = 5, cacheRepo=tmpdir) #
all.equal(notCached, reRun) # TRUE meaning the recovered cached version is same
                            # as notCached version

#Paths -- use as character string, it will take 2 complete passes to before
#  a cached copy is used
tmpdir <- file.path(tempdir(), "test")
obj <- 1:10
Cache(saveRDS, obj, file="filename.rdata", cacheRepo = tmpdir)
Cache(saveRDS, obj, file="filename.rdata", cacheRepo = tmpdir)
Cache(saveRDS, obj, file="filename.rdata", cacheRepo = tmpdir) # cached copy is loaded
# vs. which takes only 1 complete time before cached copy is loaded
Cache(saveRDS, obj, file=asPath("filename1.rdata"), cacheRepo = tmpdir)
Cache(saveRDS, obj, file=asPath("filename1.rdata"), cacheRepo = tmpdir) #cached copy is loaded

}

}
\seealso{
\code{\link[archivist]{cache}}, \code{\link{robustDigest}}
}
\author{
Eliot McIntire
}
