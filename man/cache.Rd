% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cache.R
\docType{methods}
\name{Cache}
\alias{Cache}
\alias{Cache,ANY-method}
\title{Cache method that accommodates environments, S4 methods, Rasters}
\usage{
Cache(FUN, ..., notOlderThan = NULL, objects = NULL, outputObjects = NULL,
  algo = "xxhash64", cacheRepo = NULL, compareRasterFileLength = 1e+06,
  userTags = c(), digestPathContent = FALSE, debugCache = FALSE)

\S4method{Cache}{ANY}(FUN, ..., notOlderThan = NULL, objects = NULL,
  outputObjects = NULL, algo = "xxhash64", cacheRepo = NULL,
  compareRasterFileLength = 1e+06, userTags = c(),
  digestPathContent = FALSE, debugCache = FALSE)
}
\arguments{
\item{FUN}{A function to be called.}

\item{...}{Arguments of \code{FUN} function .}

\item{notOlderThan}{load an artifact from the database only if it was created after notOlderThan.}

\item{objects}{Character vector of objects to be digested. This is only applicable
if there is a list, environment or simList with named objects
within it. Only this/these objects will be considered for caching,
i.e., only use a subset of
the list, environment or simList objects.}

\item{outputObjects}{Optional character vector indicating which objects to
return. This is only relevant for \code{simList} objects}

\item{algo}{The algorithms to be used; currently available choices are
    \code{md5}, which is also the default, \code{sha1}, \code{crc32},
    \code{sha256}, \code{sha512}, \code{xxhash32}, \code{xxhash64} and
    \code{murmur32}.}

\item{cacheRepo}{A repository used for storing cached objects.
This is optional if \code{Cache} is used inside a SpaDES module.}

\item{compareRasterFileLength}{Numeric. Optional. When there are Rasters, that
have file-backed storage, this is passed to the length arg in \code{digest}
when determining if the Raster file is already in the database.
Note: uses \code{\link[digest]{digest}} for file-backed Raster.
Default 1e6. Passed to \code{prepareFileBackedRaster}.}

\item{userTags}{A character vector with Tags. These Tags will be added to the repository along with the artifact.}

\item{digestPathContent}{Logical. Should arguments that are of class "Path"
(see examples below) have their name digested
(FALSE, the default), or their
file contents (TRUE)}

\item{debugCache}{Logical. If \code{TRUE}, then the returned object from the Cache
function will have two attributes, "debugCache1" and "debugCache2" which
are the entire list(...) and that same object, but
after all "robustDigest" calls, at the moment that it is digested using
\code{fastdigest}, respectively. This \code{attr(mySimOut, "debugCache2")} can
then be compared to
a subsequent call and individual items within the object
\code{attr(mySimOut, "debugCache1")} can be compared.}
}
\value{
As with \code{\link[archivist]{cache}}, the return is either the return
value of the function call or the cached version (i.e., the result from a previous
call to this same cached function with identical arguments).

If \code{Cache} is called within a SpaDES module, then the cached entry will automatically
get 3 extra \code{userTags}: eventTime, eventType, and moduleName. These can then be used in
\code{clearCache} to selectively remove cached objects by eventTime, eventType or moduleName.

\code{Cache} will add a tag to the artifact in the database
called \code{accessed} which will assign the time that it was
accessed, either read or write. That way, artifacts can be shown (\code{showCache})
or removed \code{clearCache} selectively based on their accessed
 dates, rather than only by their
creation dates. See example in \code{\link{clearCache}}.
}
\description{
This function takes elements from \code{\link[archivist]{cache}}, with
four very critical modifications:
1) the \code{archivist} package detects different environments as different;
2) it also does not detect S4 methods correctly due to method inheritance;
3) it does not detect objects that have file-base storage of information
(specifically \code{\link[raster]{RasterLayer-class}} objects).
4) the default hashing method is relatively slow
This version of the \code{Cache} function accommodates those four special,
though quite common, cases by:
1) converting any environments into list equivalents;
2) identifying the dispatched S4 method (including those made through
inheritance) before \code{\link[fastdigest]{fastdigest}} is called so the correct
method is being cached;
and 3) by running \code{\link[digest]{digest}} on the linked file. Currently,
only file-backed \code{Raster*} objects are digested (e.g., not \code{ff} objects,
or any other R object where the data is in a file, rather than RAM object).
4) We use \code{\link[fastdigest]{fastdigest}} internally when the object is
in RAM (i.e., not for file-backed objects0) which appears to be up to
10x faster than \code{\link[digest]{digest}}.
}
\details{
\code{Cache} (uppercase C) is used here so that it is not confused with and does
not mask the \code{archivist::cache} function.
}
\note{
As indicated above, several objects require pre-treatment before
caching will work as expected. The function \code{robustDigest} accommodates this.
It is an S4 generic, meaning that developers can produce their own methods for
different classes of objects. Currently, there are methods for several types
of classes. See \code{\link{robustDigest}} .

See \code{\link{robustDigest}} for other specifics for other classes.

In general, it is expected that caching will only be used when stochasticity
is not relevant, or if a user has achieved sufficient stochasticity (e.g., via
sufficient number of calls to \code{experiment}) such that no new explorations
of stochastic outcomes are required. It will also be very useful in a
reproducible work flow
}
\examples{
\dontrun{

library(raster)
tmpdir <- tempdir()
ras <- raster(extent(0,100,0,100), res = 1,
              vals = sample(1:5, replace=TRUE, size = 1e4),
              crs = "+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +ellps=WGS84")

# A slow operation, like GIS operation
notCached <- projectRaster(ras, crs=crs(ras), res = 5, cacheRepo=tmpdir) #
cached <- Cache(projectRaster, ras, crs=crs(ras), res = 5, cacheRepo=tmpdir) #
# 2nd time is much faster
reRun <- Cache(projectRaster, ras, crs=crs(ras), res = 5, cacheRepo=tmpdir) #
all.equal(notCached, reRun) # TRUE meaning the recovered cached version is same
                            # as notCached version


# if using with SpaDES
mySim <- simInit(times = list(start = 0.0, end = 5.0),
                 params = list(.globals = list(stackName = "landscape", burnStats = "testStats")),
                 modules = list("randomLandscapes", "fireSpread"),
                 paths = list(modulePath = system.file("sampleModules", package = "SpaDES")))

  # This functionality can be achieved within a spades call
  # compare caching ... run once to create cache
  system.time(outSim <- spades(Copy(mySim), cache = TRUE, notOlderThan = Sys.time(),
                               .plotInitialTime = NA))
  # compare... second time is fast
  system.time(outSimCached <- spades(Copy(mySim), cache = TRUE, .plotInitialTime = NA))
  all.equal(outSim, outSimCached)

  # Function caching
  ras <- raster(extent(0,1e3,0,1e3),res = 1)
  system.time(map <- Cache(gaussMap, ras, cacheRepo = cachePath(mySim),
                           notOlderThan = Sys.time()))
  # second time much faster
  system.time(mapCached <- Cache(gaussMap, ras, cacheRepo = cachePath(mySim)))

  # They are the same
  all.equal(map, mapCached)

  # Module-level
  # In this example, we will use the cache on the randomLandscapes module
  # This means that each subsequent call to spades will result in identical
  # outputs from the randomLandscapes module (only!).
  # This would be useful when only one random landscape is needed
  # simply for trying something out, or putting into production code
  # (e.g., publication, decision support, etc.)
  params(mySim)$randomLandscapes$.useCache <- TRUE
  system.time(randomSim <- spades(Copy(mySim), .plotInitialTime = NA,
                                 notOlderThan = Sys.time(), debug = TRUE))

  # user  system elapsed
  # 1.26    0.25    7.00
  # Vastly faster
  system.time(randomSimCached <- spades(Copy(mySim), .plotInitialTime = NA,
                                 debug = TRUE))
   # user  system elapsed
   # 0.22    0.00    0.24
   # Test that only layers produced in randomLandscapes are identical, not fireSpread
   layers <- list("DEM","forestAge", "habitatQuality", "percentPine","Fires")
   same <- lapply(layers, function(l) identical(randomSim$landscape[[l]],
                                        randomSimCached$landscape[[l]]))
   names(same) <- layers
   print(same) # Fires is not same because it is not in the randomLandscape module that was cached

   # Note - one can access cached items manually (rather than simply
   #    rerunning the same Cache function again)
   if (requireNamespace("archivist")) {
     # examine the cache
     showCache(mySim)
     # get the RasterLayer that was produced with the gaussMap function:
     map <- showCache(mySim, userTags = "gaussMap")$artifact \%>\%
       archivist::loadFromLocalRepo(repoDir = cachePath(mySim), value = TRUE)
   }
}

}
\seealso{
\code{\link[archivist]{cache}}, \code{\link{robustDigest}}
}
\author{
Eliot McIntire
}
