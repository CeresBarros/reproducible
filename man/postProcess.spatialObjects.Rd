% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/postProcess.R
\name{postProcess.spatialObjects}
\alias{postProcess.spatialObjects}
\alias{cropInputs}
\alias{cropInputs.default}
\alias{cropInputs.spatialObjects}
\alias{projectInputs}
\alias{projectInputs.Raster}
\alias{projectInputs.sf}
\alias{projectInputs.Spatial}
\alias{maskInputs}
\alias{maskInputs.Raster}
\alias{maskInputs.Spatial}
\alias{determineFilename}
\alias{writeOutputs}
\alias{writeOutputs.Raster}
\alias{writeOutputs.Spatial}
\alias{writeOutputs.sf}
\alias{writeOutputs.default}
\title{Post processing for \code{spatialObjects}}
\usage{
\method{postProcess}{spatialObjects}(pp, filename1 = NULL, studyArea = NULL,
  rasterToMatch = NULL, overwrite = TRUE, useSAcrs = FALSE,
  useCache = getOption("reproducible.useCache", FALSE), ...)

cropInputs(ci, studyArea, rasterToMatch, ...)

\method{cropInputs}{default}(ci, studyArea, rasterToMatch, ...)

\method{cropInputs}{spatialObjects}(ci, studyArea, rasterToMatch = NULL,
  extentToMatch = NULL, extentCRS = NULL, ...)

projectInputs(pi, targetCRS, ...)

\method{projectInputs}{Raster}(pi, targetCRS = NULL, rasterToMatch = NULL,
  ...)

\method{projectInputs}{sf}(pi, targetCRS, ...)

\method{projectInputs}{Spatial}(pi, targetCRS, ...)

maskInputs(mi, studyArea, ...)

\method{maskInputs}{Raster}(mi, studyArea, rasterToMatch, maskWithRTM = FALSE,
  ...)

\method{maskInputs}{Spatial}(mi, studyArea, ...)

determineFilename(filename2 = TRUE, filename1 = NULL,
  destinationPath = NULL, ...)

writeOutputs(wo, filename2, overwrite, ...)

\method{writeOutputs}{Raster}(wo, filename2, overwrite = FALSE, ...)

\method{writeOutputs}{Spatial}(wo, filename2, overwrite = FALSE, ...)

\method{writeOutputs}{sf}(wo, filename2, overwrite = FALSE, ...)

\method{writeOutputs}{default}(wo, filename2, ...)
}
\arguments{
\item{pp}{A \code{Spatial*}, \code{sf}, or \code{Raster*} object.}

\item{filename1}{Character string giving the file path of the \emph{input} object,
if it has one. This is then used if \code{filename2} is
specified here as \code{TRUE} (the default, and passed to
\code{\link{determineFilename}}) to name the output file,
where the resulting post-processed filename will be
\code{.prefix(basename(filename1), "Small")}.
Mostly used by \code{\link{prepInputs}}, where \code{filename2}
is missing.}

\item{studyArea}{\code{SpatialPolygons*} object used for masking and possibly cropping
if no \code{rasterToMatch} is provided.
If not in same CRS, then it will be \code{spTransform}ed to
CRS of \code{ci} before masking. Currently, this function will not reproject the
\code{ci}. Optional in \code{postProcess}. \code{\link{postProcess.spatialObjects}}}

\item{rasterToMatch}{Template \code{Raster*} object used for cropping (so extent should be
the extent of desired outcome) and reprojecting (including changing the
resolution and projection).
See details in \code{\link{postProcess.spatialObjects}}.}

\item{overwrite}{Logical. Should file being written overwrite an existing file if it
exists.}

\item{useSAcrs}{Logical. If \code{FALSE}, the default, then the desired projection
will be taken from \code{rasterToMatch} or none at all.
If \code{TRUE}, it will be taken from \code{studyArea}.}

\item{useCache}{Passed to Cache in various places. Default \code{FALSE}}

\item{...}{Additonal arguments passed to \code{\link{cropInputs}},
           \code{\link{projectInputs}}, \code{\link{maskInputs}},
           \code{\link{determineFilename}}, and \code{\link{writeOutputs}}.
           These then pass \code{...} into other functions, like
           \code{\link[raster]{writeRaster}}, or \code{sf::st_write}.
           This might include potentially important arguments like \code{datatype},
           \code{format}. Also passed to \code{projectRaster},
           with likely important arguments such as \code{method = "bilinear"}.
           See details.

\subsection{... passed to:}{
  \tabular{lccc}{
     Function                \tab Arguments \cr
    \code{cropInputs}        \tab \code{\link[raster]{crop}} \cr
    \code{projectInputs}     \tab \code{\link[raster]{projectRaster}}\cr
    \code{maskInputs}        \tab \code{\link{fastMask}} or \code{\link[raster]{intersect}}\cr
    \code{fixErrors}         \tab \code{\link[raster]{buffer}}\cr
    \code{writeOutputs}      \tab \code{\link[raster]{writeRaster}} or \code{\link[raster]{shapefile}}\cr
    \code{determineFilename} \tab \cr
  }
  * Can be overridden with \code{useSAcrs}
  ** Will mask with \code{NA}s from \code{rasterToMatch} if \code{maskWithRTM}
}}

\item{ci}{A \code{Spatial*}, \code{sf}, or \code{Raster*} object.}

\item{extentToMatch}{Optional. Can pass an extent here and a \code{crs} to
\code{extentCRS} instead of \code{rasterToMatch}. These
will override \code{rasterToMatch}, with a warning if both
passed.}

\item{extentCRS}{Optional. Can pass a \code{crs} here with an extent to
\code{extentTomatch} instead of \code{rasterToMatch}}

\item{pi}{A \code{Raster*}, \code{Spatial*} or \code{sf} object}

\item{targetCRS}{The CRS of pi at the end  of this function (i.e., the goal)}

\item{mi}{A \code{Raster*} object}

\item{maskWithRTM}{Logical. If \code{TRUE}, then the default,}

\item{filename2}{Logical or character string (a file path) for the
output file, after post processing, if saving is desired. See details.}

\item{destinationPath}{Optional. If \code{filename2} is a relative file path, then this
will be the directory of the resulting absolute file path.}

\item{wo}{The object save to disk i.e., write outputs}
}
\value{
A file of the same type as starting, but with projection (and possibly other
characteristics, including resolution, origin, extent if changed.
}
\description{
The method for spatialObjects (\code{Raster*} and \code{Spatial*}) will
crop, reproject, and mask, in that order.  This function is a wrapper for
\code{\link{cropInputs}}, \code{\link{fixErrors}}, \code{\link{projectInputs}},
\code{\link{maskInputs}} and
\code{\link{writeOutputs}}, with a decent amount of data manipulating
between these calls so that the crs match.

This function can be used to crop or reproject module inputs from raw data.

A simple wrapper around the various different tools for these GIS types.

This function can be used to mask module inputs from raw data.

If \code{filename2} is \code{logical}, then the cropped/masked
raster will be written to disk with the original \code{targetFile} name, with
\code{"Small"} prefixed to the basename(\code{targetFilename}).
If a character string, it will be the path of the saved raster.
It will be tested whether it is an absolute or relative path and used as is
if absolute or prepended with \code{destinationPath} if relative.

Can be used to write prepared inputs on disk.
}
\details{
If \code{filename2} is \code{logical}, then the output
 filename will be \code{"Small"} prefixed to the basename(\code{filename1}).
 If a character string, it
 will be the path returned. It will be tested whether it is an
 absolute or relative path and used as is if absolute or prepended with
 \code{destinationPath} if provided, and if \code{filename2} is relative.
}
\section{Post processing sequence}{


  If the \code{rasterToMatch} or \code{studyArea} are passed, then
  the following sequence will occur:

  \enumerate{
    \item Fix errors \code{\link{fixErrors}}. Currently only errors fixed are for
           \code{SpatialPolygons} using \code{buffer(..., width = 0)}.
    \item Crop using \code{\link{cropInputs}}
    \item Project using \code{\link{projectInputs}}
    \item Mask using \code{\link{maskInputs}}
    \item Determine file name \code{\link{determineFilename}}
    \item Write that file name to disk, optionally \code{\link{writeOutputs}}
  }

  NOTE: checksumming does not occur during the post-processing stage, as
  there are no file downloads. To achieve fast results, wrap
  \code{prepInputs} with \code{Cache}

  NOTE: \code{sf} objects are still very experimental.
}

\section{File naming}{


  Post processing addresses several scenarios, and depending on which scenario,
  file names are subtly different. For example, \code{Raster} objects may have
  file-backed data, and so \emph{possess a file name}, whereas \code{Spatial}
  objects do not. Similarly, there may or may not be a desire to write an
  object to disk after all post processing. This subtlety means that there are
  two file names that may be at play: the "input" file name (\code{filename1}),
  and the "output" filename (\code{filename2}).
  When this is used \emph{only} with post process, it is straight forward.
  However, when \code{postProcess} is used within a \code{prepInputs} call,
  the \code{filename1} file is actually the file name of the downloaded file
  (i.e., what name to give to the downloaded  object) and the \code{filename2}
  is the file name of the of post-processed file.
}

\section{Passing \code{rasterToMatch} and/or \code{studyArea}}{


Depending on which of these were passed, different things will happen to the
\code{targetFile} located at \code{filename1}.

\subsection{If \code{targetFile} is a \code{Raster*} object:}{
  \tabular{lccc}{
                      \tab \code{rasterToMatch} \tab \code{studyArea} \tab             Both \cr
    \code{extent}     \tab Yes                  \tab   Yes        \tab \code{rasterToMatch} \cr
    \code{resolution} \tab Yes                  \tab   No         \tab \code{rasterToMatch} \cr
    \code{projection} \tab Yes                  \tab   No*        \tab \code{rasterToMatch}*\cr
    \code{alignment}  \tab Yes                  \tab   No         \tab \code{rasterToMatch} \cr
    \code{mask}       \tab No**                 \tab   Yes        \tab \code{studyArea}**   \cr
  }
  * Can be overridden with \code{useSAcrs}
  ** Will mask with \code{NA}s from \code{rasterToMatch} if \code{maskWithRTM}
}

\subsection{If \code{targetFile} is a \code{Spatial*} object:}{
  \tabular{lccc}{
                      \tab \code{rasterToMatch} \tab \code{studyArea} \tab             Both \cr
    \code{extent}     \tab Yes                  \tab   Yes        \tab \code{rasterToMatch} \cr
    \code{resolution} \tab NA                   \tab   NA         \tab NA                   \cr
    \code{projection} \tab Yes                  \tab   No*        \tab \code{rasterToMatch}*\cr
    \code{alignment}  \tab NA                   \tab   NA         \tab NA                   \cr
    \code{mask}       \tab No                   \tab   Yes        \tab \code{studyArea}     \cr
  }
  * Can be overridden with \code{useSAcrs}
}
}

\examples{

# download a zip file from internet, unzip all files, load as shapefile, Cache the call
dPath <- file.path(tempdir(), "ecozones")
shpEcozone <- prepInputs(destinationPath = dPath,
                         url = "http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip")


#' # Add a study area to Crop and Mask to
# Create a "study area"
library(sp)
library(raster)
coords <- structure(c(-122.98, -116.1, -99.2, -106, -122.98, 59.9, 65.73, 63.58, 54.79, 59.9),
                    .Dim = c(5L, 2L))
Sr1 <- Polygon(coords)
Srs1 <- Polygons(list(Sr1), "s1")
StudyArea <- SpatialPolygons(list(Srs1), 1L)
crs(StudyArea) <- "+init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"


##########
shpEcozonePostProcessed <- postProcess(shpEcozone, studyArea = StudyArea)

# Try manually, individual pieces
shpEcozoneCropped <- cropInputs(shpEcozone, StudyArea)
shpEcozoneClean <- fixErrors(shpEcozone)
shpEcozoneMasked <- maskInputs(shpEcozone, StudyArea)

}
\author{
Eliot McIntire

Jean Marchal

Eliot McIntire

Jean Marchal

Eliot McIntire

Jean Marchal
}
