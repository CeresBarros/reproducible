% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cache-tools.R
\docType{methods}
\name{clearCache}
\alias{clearCache}
\alias{clearCache,ANY-method}
\alias{showCache}
\alias{showCache,ANY-method}
\alias{keepCache}
\alias{keepCache,ANY-method}
\title{\code{showCache}, \code{clearCache} and \code{keepCache}}
\usage{
clearCache(x, userTags = character(), after, before, ...)

\S4method{clearCache}{ANY}(x, userTags = character(), after, before, ...)

showCache(x, userTags = character(), after, before, ...)

\S4method{showCache}{ANY}(x, userTags = character(), after, before, ...)

keepCache(x, userTags = character(), after, before, ...)

\S4method{keepCache}{ANY}(x, userTags = character(), after, before, ...)
}
\arguments{
\item{x}{A simList or a directory containing a valid archivist repository}

\item{userTags}{Character vector. If used, this will be used in place of the \code{after} and
\code{before}. Specifying one or more \code{userTag} here will
clear all objects that
match those tags. Matching is via regular expresssion, meaning
partial matches
will work unless strict beginning (^) and end ($) of string
characters are used. Matching
will be against any of the 3 columns returned by \code{showCache()},
i.e., artifact, tagValue or tagName. Also, length \code{userTags} > 1,
then matching is by `and`. For `or` matching, use | in a single character
string. See examples.}

\item{after}{A time (POSIX, character understandable by data.table).
Objects cached after this time will be shown or deleted.}

\item{before}{A time (POSIX, character understandable by data.table).
Objects cached before this time will be shown or deleted.}

\item{...}{Other arguments. Currently unused.

If neither \code{after} or \code{before} are provided, nor \code{userTags},
 then all objects will be removed.
If both \code{after} and \code{before} are specified, then all objects between \code{after} and
\code{before} will be deleted.
If \code{userTags} is used, this will override \code{after} or \code{before}.}
}
\value{
Will clear all (or that match \code{userTags}, or between \code{after} or \code{before})
objects from the repository located at \code{cachePath} of the sim object,
if \code{sim} is provided, or located in \code{cacheRepo}. Also returns a data.table invisibly
of the removed items.
}
\description{
These are wrappers around \code{archivist} package
functions, specific to simList objects.
They allow the user a bit of control over what is being cached.
}
\details{
\code{keepCache} can be used to pare down the cache to only keep
a set of archives based on userTags or times.

\code{clearCache} is the opposite, where items can be removed by
userTag or times
}
\examples{
\dontrun{
clearCache(mySim)

mySim <- simInit(
  times = list(start = 0.0, end = 1.0, timeunit = "year"),
  params = list(
    .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
    # Turn off interactive plotting
    fireSpread = list(.plotInitialTime = NA),
    caribouMovement = list(.plotInitialTime = NA),
    randomLandscapes = list(.plotInitialTime = NA, .useCache = "init")
  ),
  modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
  paths = list(modulePath = system.file("sampleModules", package = "SpaDES"),
               outputPath = tmpdir,
               cachePath = tmpdir),
  # Save final state of landscape and caribou
  outputs = data.frame(objectName = c("landscape", "caribou"),
                       stringsAsFactors = FALSE)
)

## the caching is inside randomLandscape module
sims <- spades(Copy(mySim), notOlderThan = Sys.time())
showCache(mySim)

ranNums <- Cache(runif, 4, cacheRepo=cachePath(mySim), userTags = "objectName:a")

showCache(mySim, userTags = c("objectName"))
showCache(mySim, userTags = c("^a$")) # regular expression ... "a" exactly
showCache(mySim, userTags = c("eventTime")) # show only cached objects made during spades call

clearCache(mySim, userTags = c("eventTime")) # remove only cached objects made during spades call
showCache(mySim) # only those made during spades call they are gone

# example using the "accessed" tag
 clearCache(mySim)
 sims <- spades(Copy(mySim), notOlderThan = Sys.time())
 ranNums <- Cache(runif, 4, cacheRepo=cachePath(mySim), userTags = "objectName:a")
 # access it again, but "later"
 Sys.sleep(1)
 sims <- spades(Copy(mySim)) # i.e., this is a "read" operation, does not create a new artifact

 wholeCache <- showCache(mySim)
 # keep only items accessed "recently"
 onlyRecentlyAccessed <- showCache(mySim,
                                   userTags = max(wholeCache[tagKey=="accessed"]$tagValue))
 # inverse join with 2 data.tables ... using: a[!b]
     # i.e., return all of wholeCache that was not recently accessed
 toRemove <- unique(wholeCache[!onlyRecentlyAccessed], by="artifact")$artifact
 clearCache(mySim, toRemove) # remove ones not recently accessed
 showCache(mySim) # still has more recently accessed,
                  #  based on time passed to onlyRentlyAccessed

 # keepCache examples
 # keep only those cached items from the last 24 hours
 keepCache(mySim, after = Sys.time() - dday(1))

 # Keep all Cache items that happened within a spades call
 keepCache(mySim, userTags = "spades")
 # Remove all Cache items that happened within a spades call
 clearCache(mySim, userTags = "spades")

 # Default userTags is "and" matching. For "or" matching use |
 ranNums <- Cache(runif, 4, cacheRepo=cachePath(mySim), userTags = "objectName:a")
 ranNums <- Cache(rnorm, 4, cacheRepo=cachePath(mySim), userTags = "objectName:a")
 showCache(mySim) # shows spades, runif and rnorm objects
 showCache(mySim, userTags = c("spades","rnorm")) # shows nothing because object
                                                  #  has both spades and rnorm
 showCache(mySim, userTags = "spades|rnorm") # "or" search
 keepCache(mySim, userTags = "spades|rnorm") # keep all with spades or rnorm
 showCache(mySim) # shows spades, runif and rnorm objects

}
\dontrun{
showCache(mySim)
}
}
\seealso{
\code{\link[archivist]{splitTagsLocal}}.
}
